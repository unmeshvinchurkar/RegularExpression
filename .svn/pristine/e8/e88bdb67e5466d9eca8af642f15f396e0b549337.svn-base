%TERMINALS%
+
-
*
/
(
)
{
}
INTEGER
FLOAT
STRING
CHAR
BOOLEAN
COMMA
$
EQUALS
TYPE
VARNAME
SPACE_EMPTY
FUNCTION
SEMICOLON
NOT_OPERATOR
LOGICAL_OPERATOR
or
and
COMPARISON_OPERATOR
FOR
WHILE
BOOL_VALUE
SINGLE_OPERATOR
VOID
COLON
IF
ELSE
BREAK
CONTINUE
RETURN
%END%


%GRAMMER%

VALUE=STRING
VALUE=CHAR
VALUE=BOOLEAN

S=PROGRAM$ [0]
PROGRAM=PROGRAM FUNCTION_STMT [0]
PROGRAM=FUNCTION_STMT [0]

FUNCTION_STMT=RETURN_TYPE FUNCTION_DECL BODY [2:FunctionNode.class]
RETURN_TYPE=VOID [1]
RETURN_TYPE=TYPE [1]
BODY={STATEMENT_LIST} [0:BodyNode.class]
BODY={}  [0:BodyNode.class]
FUNCTION_DECL= FUNCTION VARNAME (FUNCTION_PARAM) [1]
FUNCTION_DECL= FUNCTION VARNAME () [1]
FUNCTION_PARAM=FUNCTION_PARAM COMMA FUNCTION_PARAM_TERM [0]
FUNCTION_PARAM=FUNCTION_PARAM_TERM [0]
FUNCTION_PARAM_TERM=TYPE VARNAME [0:FunctionParamNode.class]


STATEMENT_LIST={} [0]
STATEMENT_LIST=STATEMENT_LIST STMT_TERM [0]
STATEMENT_LIST=STMT_TERM [0]
STMT_TERM=STMT [0]
STMT_TERM={STATEMENT_LIST} [0]

SEMI_COL=SEMI_COL SEMICOLON  [0]
SEMI_COL=SEMICOLON [1]

STMT=ASSIGN_STMT SEMI_COL  [1]
STMT=DECLARATION_STMT SEMI_COL [1]
STMT=WHILE_STMT [1]
STMT=FOR_STMT [1]
STMT=CALL_EXPR SEMI_COL [1]
STMT=SINGLE_EXP SEMI_COL [0]
STMT=IF_STMT [0]
STMT=JUMP_STMT [1:JumpStmtNode.class]

DECLARATION_STMT=TYPE D_TERM [0:DeclStatementNode.class]
D_TERM=D_TERM COMMA D_TERM [0:AssignStatementNode.class]
D_TERM=VARNAME EQUALS EXPR [2]
D_TERM=VARNAME EQUALS LOGICAL_EXPR [2]
D_TERM=VARNAME EQUALS VALUE [2]
D_TERM=VARNAME [1]

ASSIGN_STMT=VARNAME EQUALS EXPR [0:AssignStatementNode.class]
ASSIGN_STMT=VARNAME EQUALS LOGICAL_EXPR [2]

WHILE_STMT=WHILE_DECL WHILE_BODY [1]
WHILE_DECL= WHILE(LOGICAL_EXPR) [1:WhileStmtNode.class]
WHILE_BODY={STATEMENT_LIST} [0]
WHILE_BODY={} [0]

JUMP_STMT=BREAK [1]
JUMP_STMT=CONTINUE [1]
JUMP_STMT=RETURN [1:ReturnExprNode.class]
JUMP_STMT=RETURN EXPR [1:ReturnExprNode.class]
JUMP_STMT=RETURN LOGICAL_EXPR [1:ReturnExprNode.class]
JUMP_STMT=RETURN VALUE [1:ReturnExprNode.class]

IF_STMT=IF_STMT_TERM IFELSE_BODY [1]
IF_STMT=IF_STMT_TERM ELSE_STMT_TERM [0]
IF_STMT_TERM=IF(LOGICAL_EXPR) IFELSE_BODY [1:IfStmtNode.class]
ELSE_STMT_TERM=ELSE IFELSE_BODY [1:ElseStmtNode.class]
IFELSE_BODY={STATEMENT_LIST} [0]
IFELSE_BODY={} [0]

FOR_STMT=FOR_DECL FOR_BODY [1]
FOR_DECL=FOR(FOR_INIT_STMT SEMICOLON LOGICAL_EXPR SEMICOLON ASSIGN_STMT) [1:ForStmtNode.class]
FOR_INIT_STMT=DECLARATION_STMT [0]
FOR_INIT_STMT=ASSIGN_STMT [0]
FOR_BODY={STATEMENT_LIST} [0]
FOR_BODY={} [0]

EXPR=EXPR+TERM [2:ExprNode.class]
EXPR=EXPR-TERM [2:ExprNode.class]
EXPR=TERM [0]
TERM=TERM*FACTOR [2:ExprNode.class]
TERM=TERM/FACTOR [2:ExprNode.class]
TERM=CALL_EXPR [1]
TERM=SINGLE_EXP [1]
TERM=FACTOR [1]
FACTOR=(EXPR) [2]
FACTOR=INTEGER [1]
FACTOR=FLOAT [1]
FACTOR=VARNAME [1]

LOGICAL_EXPR=LOGICAL_EXPR or T_TERM [2:LogicalExprNode.class]
LOGICAL_EXPR=T_TERM [1]
T_TERM=T_TERM and F_TERM [2:LogicalExprNode.class]
T_TERM=F_TERM [0]
F_TERM= EXPR COMPARISON_OPERATOR EXPR [2:LogicalExprNode.class]
F_TERM=CALL_EXPR [0]
F_TERM=(LOGICAL_EXPR) [2]
F_TERM=BOOL_VALUE [1]
F_TERM=VARNAME [1]

CALL_EXPR=VARNAME(FUNCTION_ARGS) [0:CallExprNode.class]
CALL_EXPR=VARNAME() [1]
FUNCTION_ARGS=FUNCTION_ARGS COMMA FUN_ARG [0]
FUNCTION_ARGS=FUN_ARG [0]
FUN_ARG=EXPR [0]
FUN_ARG=LOGICAL_EXPR [0]
FUN_ARG=VALUE [1]

SINGLE_EXP=VARNAME SINGLE_OPERATOR [0:SingleExpr.class]
SINGLE_EXP=SINGLE_OPERATOR VARNAME [0:SingleExpr.class]
%END%
